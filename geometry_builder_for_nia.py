# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeometryBuilderForNIA
                                 A QGIS plugin
 This plugin extracts geometry from database and builds objects for NIA
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-02-14
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Samiul Choudhury@Patching Associates Acoustical Engieering Ltd.
        email                : schoudhury@patchingassociates.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QThread
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import *
from qgis.gui import QgsFileWidget
import sys
import os
import requests
import io
import zipfile
import os.path
import re

# Global Variable
CURRENT_DIR = os.path.dirname(__file__)
TEMP_DIR = os.path.join(CURRENT_DIR, 'temp')
LAYER_STUDY_AREA = "Extent"
LAYER_DEM_MAP_INDEX = "DEM Map Index"

# Add processing module to system path and import processing module
with open(os.path.join(CURRENT_DIR, 'pathlist.txt'), 'r') as f:
    content = [x.strip() for x in f.readlines()]
try:
    processingPath = content[content.index('[PROCESSING]') + 1]
except ValueError:
    pass

try:
    DATA_DIR = content[content.index('[DATA_DIR]') + 1]
except ValueError:
    pass
    
sys.path.append(processingPath)
import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .geometry_builder_for_nia_dialog import GeometryBuilderForNIADialog
import os.path



class GeometryBuilderForNIA:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GeometryBuilderForNIA_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GeometryBuilderForNIA')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GeometryBuilderForNIA', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/geometry_builder_for_nia/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Geometry Builder for NIA'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
   
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GeometryBuilderForNIA'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""
        
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GeometryBuilderForNIADialog()
        
            # Event Handlers
            self.dlg.radioButtonLatLong.toggled.connect(lambda:self.handler_lat_long_radio_button(self.dlg.radioButtonLatLong))
            self.dlg.pushButtonShowDEMMapIndices.pressed.connect(self.show_dem_map_indices)
            self.dlg.pushButtonZoomToLocation.pressed.connect(self.zoom_to_location)
            self.dlg.pushButtonDownloadDEM.pressed.connect(self.download_dems)
            self.dlg.pushButtonExtract.pressed.connect(self.extract_objects)
            self.dlg.pushButtonCancel.pressed.connect(self.on_close_plugin)
            #self.dlg.closingPlugin.connect(self.on_close_plugin)
            
        # Initialize fields
        self.originalCrs = QgsProject.instance().crs()
        self.dlg.lineEditLocation.clear()
        self.dlg.lineEditStudyAreaWidth.setText("8000")
        self.dlg.lineEditStudyAreaHeight.setText("8000")
        self.dlg.listWidgetDEMLog.clear()
        self.dlg.plainTextEditProcessLog.clear()
        self.dlg.radioButtonLatLong.setChecked(True)
        self.dlg.radioButtonDownloadAll.setChecked(True)
        self.dlg.progressBar.setVisible(False)
        
        # Clean temp directory
        self.clean_temp_directory()
        
        # show the dialog
        self.dlg.show()
        
        # Run the dialog event loop
        result = self.dlg.exec_()
#        print("result: {}".format(result))
        self.on_close_plugin()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            print("Im here")
            pass

    def on_close_plugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == LAYER_STUDY_AREA or lyr.name() == LAYER_DEM_MAP_INDEX:
                QgsProject.instance().removeMapLayer(lyr.id())

        # reset canvas crs
#        self.iface.mapCanvas().setDestinationCrs(self.originalCrs)
#        QgsProject.instance().setCrs(self.originalCrs)
        self.iface.mapCanvas().refresh()

        # clean temp directory
        self.clean_temp_directory()

        # disconnects
        #self.dlg.closingPlugin.disconnect(self.on_close_plugin)
        #self.dlg = None

    def handler_lat_long_radio_button(self, radioButton):
        if radioButton.isChecked() == True:
            #self.dlg.lineEditLocation.setText("")
            self.dlg.lineEditLocation.setPlaceholderText("latitude, longitude")
        else:
            #self.dlg.lineEditLocation.setText("")
            self.dlg.lineEditLocation.setPlaceholderText("lsd-sec-twn-rng w mer")
    
    def get_utm_zone_epsg(self, latitude, longitude):
        point = QgsPointXY(float(longitude), float(latitude))
        #point = QgsPointXY(-124.09703019773282051, 54.10617360603363579)
        filePath = os.path.join(DATA_DIR, 'utm_zones.shp')
        #filePath = os.path.join(CURRENT_DIR, 'shapefiles', 'utm_zones.shp')
        #filePath = r"X:\_Templates from SC\0_IPPs\2020 - QGIS Plugins\geometry_builder_for_nia\shapefiles\utm_zones.shp"
        utmLayer = QgsVectorLayer(filePath, 'utm zones', 'ogr')
        
        utmSpatialIndex = QgsSpatialIndex(utmLayer.getFeatures())
        intersect = utmSpatialIndex.intersects(QgsRectangle(point, point))
        if not intersect:
            return
        utmFeatures = list(utmLayer.getFeatures(QgsFeatureRequest().setFilterFid(intersect[0])))
        utmZone = int(utmFeatures[0].attributes()[0])

        epsgCodes = {
            7: 32607,
            8: 32608,
            9: 32609,
            10: 32610,
            11: 32611,
            12: 32612,
            13: 32613,
            14: 32614,
            15: 32615,
            16: 32616,
            17: 32617,
            18: 32618,
            19: 32619,
            20: 32620,
            21: 32621,
            22: 32622,
          }
        return utmZone, epsgCodes[utmZone]

    def transform_crs(self, point, sourceEPSG, destinationEPSG):
        sourceCRS = QgsCoordinateReferenceSystem(sourceEPSG)
        destinationCRS = QgsCoordinateReferenceSystem(destinationEPSG)
        xform = QgsCoordinateTransform(sourceCRS, destinationCRS,QgsProject.instance())
        return xform.transform(point)
    
    def validate_location_input(self, inputType, locationString):
        regexForLatLong = r'^\d*?\.\d*,-\d*?\.\d*$'
        regexForLSD = r'^(0[1-9]|[1-9]|1[0-6])-(0[1-9]|[1-9]|[1-2][0-9]|3[0-6])-(00[1-9]|0[1-9]|[1-9]|0[1-9][0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-6])-(0[1-9]|[1-9]|[1-2][0-9]|3[0])(W|w|\sw|\sW)[1-8]$'
        if inputType == "LatLong":
            match = re.match(regexForLatLong, locationString)
        else:
            match = re.match(regexForLSD, locationString)
        
        if match:
            return True
        else:
            return False
    
    def convert_lsd_to_lat_long(self, lsd):
        url = "https://locator.scadalink.com/locator/latlng?dls={}".format(lsd)
        headers = {
            'Authorization': 'Basic bW9iaWxlOkRDM2VhNjdVbDlZZE9iYg=='
        }
        r = requests.get(url, headers=headers)
        return r.text

    def zoom_to_location(self):
        self.dlg.progressBar.setVisible(True) # Show progress bar
        locInput = self.dlg.lineEditLocation.text().replace(" ","")
        
        if self.dlg.radioButtonLatLong.isChecked():
            validation = self.validate_location_input("LatLong", locInput)
        else:
            validation = self.validate_location_input("LSD", locInput)
        
        if not validation:
            self.dlg.plainTextEditProcessLog.appendPlainText("Invalid Location Input!")
            self.dlg.progressBar.setVisible(False) # Hide progress bar
            return
        
        #convert lsd to lat long
        if not self.dlg.radioButtonLatLong.isChecked():
            locInput = self.convert_lsd_to_lat_long(locInput)
        
        # Processing form input values
        location = locInput.split(",")        
        studyAreaWidth = self.dlg.lineEditStudyAreaWidth.text()
        studyAreaheight = self.dlg.lineEditStudyAreaHeight.text()

        try:
            siteLatitude = float(location[0])
            siteLongitude = float(location[1])
            studyAreaWidth = float(studyAreaWidth)
            studyAreaheight = float(studyAreaheight)
        except:
            errMsg = "Invalid input. Please ensure entered values are numerical and valid!"
            self.dlg.plainTextEditProcessLog.appendPlainText(errMsg)
            self.dlg.progressBar.setVisible(False) # Hide progress bar
            return

        # zoom to location and create a bounding box. To measure true distance, we need to project the
        # lat long coordinates to a projected coordinate system.        
        self.utmZone, self.utmEPSG = self.get_utm_zone_epsg(siteLatitude, siteLongitude)
        siteLocation = QgsPointXY(siteLongitude, siteLatitude)

        projectedSiteLocation = self.transform_crs(siteLocation, 4326, self.utmEPSG)
        lowerLeftCorner = QgsPointXY(projectedSiteLocation.x() - studyAreaWidth/2, projectedSiteLocation.y() - studyAreaheight/2)
        upperRightCorner = QgsPointXY(projectedSiteLocation.x() + studyAreaWidth/2, projectedSiteLocation.y() + studyAreaheight/2)

        # change canvas projections
        self.iface.mapCanvas().setDestinationCrs(QgsCoordinateReferenceSystem(self.utmEPSG))

        # define extent boundary
        self.extent = QgsRectangle(lowerLeftCorner, upperRightCorner)
        #self.iface.mapCanvas().setExtent(self.extent.buffered(self.extent.width()*1.01))
        
        # Show extent on map using a memory layer
        layerID = self.return_layer_id_from_name(LAYER_STUDY_AREA)
        if layerID is not None:
            QgsProject.instance().removeMapLayer(layerID)
            
        self.studyAreaLayer = self.generate_study_area_memory_layer(self.extent, self.utmEPSG)
        self.iface.mapCanvas().setExtent(self.studyAreaLayer.extent())
        
        # update the dems found list with dems at this location
        self.dlg.listWidgetDEMLog.clear()
        demMapIndexLayer = QgsVectorLayer(os.path.join(DATA_DIR, 'index.shp'), 'index', 'ogr')
        # reproject the index layer to the correct utm zone
        tempDir = os.path.join(CURRENT_DIR, 'temp')
        projectedMapIndexLayerLocation = os.path.join(tempDir, 'projected_index.shp')
        print(projectedMapIndexLayerLocation)
        params = { 
            'INPUT' : demMapIndexLayer, 
            'TARGET_CRS': "EPSG:{}".format(self.utmEPSG),
            'OUTPUT' : projectedMapIndexLayerLocation
            }
        result = processing.run("native:reprojectlayer", params)
        # Load reprojected layer
        projectedMapIndexLayer = QgsVectorLayer(projectedMapIndexLayerLocation, 'projected_index_layer', 'ogr')
        projectedLayerSpatialIndex = QgsSpatialIndex(projectedMapIndexLayer.getFeatures())
#        index_features = [feature for feature in proj_index_layer.getFeatures()]
#        for feat in index_features:
#            index_layer_spatial_index.insertFeature(feat)
        intersect = projectedLayerSpatialIndex.intersects(self.extent)
        if intersect:
            #self.dockwidget.lst_download_table.clear()
            #request = QgsFeatureRequest()
            #request.setFilterFids(intersect)
            demFeatures = projectedMapIndexLayer.getFeatures(QgsFeatureRequest().setFilterFids(intersect))
            demAttributes = [i.attributes()[0] for i in demFeatures]
            self.dlg.listWidgetDEMLog.addItems(demAttributes)
        
        self.dlg.progressBar.setVisible(False) # Hide progress bar
#            for demFeature in demFeatures:
#                self.dlg.listWidgetDEMLog.appendPlainText(demFeature.attributes()[0])
#                list_item = QListWidgetItem()
#                list_item.setText(feat.attributes()[0])
#                self.dockwidget.lst_download_table.addItem(list_item)
    
    def generate_study_area_memory_layer(self, extent, epsg):
        studyArea = self.iface.addVectorLayer("Polygon?crs=EPSG:{}".format(epsg), LAYER_STUDY_AREA, "memory")
        studyArea.loadNamedStyle(os.path.join(DATA_DIR, 'study_area.qml'))
        studyAreaFeature = QgsFeature()
        studyAreaGeometry = extent.asWktPolygon()
        studyAreaFeature.setGeometry(QgsGeometry.fromWkt(studyAreaGeometry))
        studyArea.dataProvider().addFeatures([studyAreaFeature])
        return studyArea


    def extract_objects(self):
        self.dlg.progressBar.setVisible(True) # Show progress bar
        # Check if there is any Study Area Layer
        studyAreaLayerID = self.return_layer_id_from_name(LAYER_STUDY_AREA)
        if studyAreaLayerID is None:
            self.dlg.plainTextEditProcessLog.appendPlainText("No study area is generated!")
            self.dlg.progressBar.setVisible(False) # Hide progress bar
            return
        
        # Check if any object is selected
        items = [self.dlg.checkBoxContour, self.dlg.checkBoxRoad, self.dlg.checkBoxRailway, self.dlg.checkBoxWaterBody ]
        objectSourceFileNames = ['contour.shp', 'Road.shp', 'Railway.shp', 'BaseWaterbodyPolygon.shp']
        projectedObjectSourceFileNames = ['contour_projected.shp', 'Road_projected.shp', 'Railway_projected.shp', 'BaseWaterbodyPolygon_projected.shp']
        objectLayerNames = ['Contour', 'Road', 'Railway', 'Waterbody']
        
        itemStates = [item.isChecked() for item in items]
        if itemStates.count(True) == 0:
            self.dlg.plainTextEditProcessLog.appendPlainText("No object is selected for export operation!")
            self.dlg.progressBar.setVisible(False) # Hide progress bar
            return
        
        # Select Folder to Save Extracted Objects
        dirSelectionDialog = QFileDialog(options=QFileDialog.ShowDirsOnly)
        res = dirSelectionDialog.getExistingDirectoryUrl()
        destinationDirPath = res.toLocalFile()
        if destinationDirPath == "":
            self.dlg.plainTextEditProcessLog.appendPlainText("No directory is selected to save extracted objects!")
            self.dlg.progressBar.setVisible(False) # Hide progress bar
            return
        
        # Get Study Area EPSG
        studyAreaLayer = [layer for layer in self.iface.mapCanvas().layers() if layer.id() == studyAreaLayerID][0]
        utmEPSG = studyAreaLayer.crs()
        print(utmEPSG)
        errFlag = False
        # Loop for Extracting Objects
        for i, obj in enumerate(objectLayerNames):
            try:
                if itemStates[i] == True:                
                    if obj != 'Contour': # Handle contour differently
                        objSourceLayer = QgsVectorLayer(os.path.join(DATA_DIR, objectSourceFileNames[i]), obj, 'ogr')
                        if not objSourceLayer:
                            print("Not generated correctly")
                            errFlag = True
                        
                        #objSourceLayer.setCrs(utmEPSG)
                        #clippedObjLayer = QgsVectorLayer(os.path.join(DATA_DIR, '{}.shp'.format(obj)), obj, 'ogr')
                        #reprojectedObjectSourceLayer = QgsVectorLayer(os.path.join(TEMP_DIR, projectedObjectSourceFileNames[i]), obj, 'ogr')
                        clippedObjPath = os.path.join(TEMP_DIR, '{}.shp'.format(obj))
                        params = { 
                            'INPUT' : objSourceLayer, 
                            'OUTPUT' : clippedObjPath, 
                            'OVERLAY' : LAYER_STUDY_AREA 
                            }
                        context = QgsProcessingContext()
                        context.setInvalidGeometryCheck(QgsFeatureRequest.GeometrySkipInvalid)
                        result = processing.run("native:clip", params)
                        # reproject road layer to the correct utm zone
                        #clippedLayer = QgsVectorLayer(clippedObjPath, obj, 'ogr')
                        clippedReprojectedLayerPath = os.path.join(destinationDirPath, '{}.shp'.format(obj))
                        params = { 
                            'INPUT' : clippedObjPath, 
                            'TARGET_CRS': utmEPSG,#"EPSG:{}".format(utmEPSG),
                            'OUTPUT' : clippedReprojectedLayerPath
                            }
                        result = processing.run("native:reprojectlayer", params)
                        
                        self.iface.addVectorLayer(clippedReprojectedLayerPath,obj,'ogr')
                        self.dlg.plainTextEditProcessLog.appendPlainText("{} object extraction complete!".format(obj))
                    else:
                        finalContourPath  = self.generate_contours(obj, destinationDirPath, utmEPSG)
                        if finalContourPath is None:
                            errFlag = True
                        else:
                            self.iface.addVectorLayer(finalContourPath,obj,'ogr')
                            self.dlg.plainTextEditProcessLog.appendPlainText("{} object extraction complete!".format(obj))
                            
            except:
                errFlag = True
        if errFlag == True:
            self.dlg.plainTextEditProcessLog.appendPlainText("Could not extract all of the selected objects!")
        else:
            self.dlg.plainTextEditProcessLog.appendPlainText("Selected objects have been extracted successfully!")
        self.dlg.progressBar.setVisible(False) # Hide progress bar
    
    def return_layer_id_from_name(self, layerName):
        desiredLayer = [layer.id() for layer in self.iface.mapCanvas().layers() if layer.name()==layerName]
        if len(desiredLayer) == 0:
            res = None
        else:
            res = desiredLayer[0]
        return res

    def show_dem_map_indices(self):
        # check if it's already loaded
        layerNames = [layer.name() for layer in self.iface.mapCanvas().layers()]
        if LAYER_DEM_MAP_INDEX in layerNames:
            return
        
        indexFilePath = os.path.join(DATA_DIR, 'index.shp')
        indexStylePath = os.path.join(DATA_DIR, 'index.qml')
        indexVectorLayer = self.iface.addVectorLayer(indexFilePath, LAYER_DEM_MAP_INDEX, 'ogr')
        indexVectorLayer.setName(LAYER_DEM_MAP_INDEX)
        indexVectorLayer.loadNamedStyle(indexStylePath)
        
    def download_dems(self): # From Vincent's Code
        self.dlg.progressBar.setVisible(True) # Show progress bar
        demNames = []
        if not self.dlg.radioButtonDownloadAll.isChecked():
            for row in range(self.dlg.listWidgetDEMLog.count()):
                if self.dlg.listWidgetDEMLog.item(row).isSelected():
                    demNames.append(self.dlg.listWidgetDEMLog.item(row).text())
            if len(demNames) == 0:
                self.dlg.plainTextEditProcessLog.appendPlainText("No DEM is selected!")
                self.dlg.progressBar.setVisible(False) # Hide progress bar
                return
        else:
            # get download links from attributes of index file
            for row in range(self.dlg.listWidgetDEMLog.count()):
                item = self.dlg.listWidgetDEMLog.item(row)
                demNames.append(item.text())
            if len(demNames) == 0:
                self.dlg.plainTextEditProcessLog.appendPlainText("No DEM is found!")
                self.dlg.progressBar.setVisible(False) # Hide progress bar
                return
        
        self.links = []
        #self.itemIDs = []
        #current_dir = os.path.dirname(__file__)
        indexLayer = QgsVectorLayer(os.path.join(DATA_DIR, 'index.shp'), 'index', 'ogr')
        for feature in indexLayer.getFeatures():
            if feature.attributes()[0] in demNames:
                self.links.append(feature.attributes()[1])
                #self.itemIDs.append(feature.attributes()[0])
        #print(self.itemIDs)
        self.currentLink = self.links.pop(0)
        
        #print(self.current_link)
        self.start_downloads()

    def start_downloads(self): # From Vincent's Code
        self.thread = download_thread(self.currentLink, TEMP_DIR)
        self.thread.finished.connect(lambda:self.move_to_next_thread(self.thread.msg))
        self.thread.start()
        currentIndex = os.path.basename(self.currentLink).split('_')[2]
        for row in range(self.dlg.listWidgetDEMLog.count()):
            item = self.dlg.listWidgetDEMLog.item(row)
            if item.text() == currentIndex:
                item.setText("{} - Downloading...".format(currentIndex))

    def move_to_next_thread(self, msg):
        # update item in list to show completion
        for row in range(self.dlg.listWidgetDEMLog.count()):
            item = self.dlg.listWidgetDEMLog.item(row)
            if 'Downloading...' in item.text():
                item.setText("{}".format(item.text().replace('Downloading...', msg)))

        if not self.links:
            self.downloads_finished()
            return

        self.currentLink = self.links.pop(0)
        self.thread = download_thread(self.currentLink, TEMP_DIR)
        self.thread.finished.connect(lambda:self.move_to_next_thread(self.thread.msg))
        self.thread.start()
        currentIndex = os.path.basename(self.currentLink).split('_')[2]
        for row in range(self.dlg.listWidgetDEMLog.count()):
            item = self.dlg.listWidgetDEMLog.item(row)
            if item.text() == currentIndex:
                item.setText("{} - Downloading...".format(currentIndex))

    def downloads_finished(self):
        self.dlg.plainTextEditProcessLog.appendPlainText("Download complete!")
        self.dlg.progressBar.setVisible(False) # Hide progress bar
        self.dlg.checkBoxContour.setEnabled(True)
        self.dlg.labelContourResolution.setEnabled(True)
        self.dlg.spinBoxContourResolution.setEnabled(True)
        #self.dockwidget.contour_group.setEnabled(True)

    def generate_contours(self, obj, destinationDirPath, utmEPSG):
        # merge dems if we have more than 1
        #current_dir = os.path.dirname(__file__)
        #temp_dir = os.path.join(current_dir, 'temp')
        inputs = [os.path.join(TEMP_DIR, f) for f in os.listdir(TEMP_DIR) if (f.endswith('.tif') and 'cdem_dem' in f)]
        clippedDemLayers = []
        
        for i, input in enumerate(inputs):
            # add layers to registry prior to run processing algorithm so registry takes ownership. This allows removal of file locks
            # after process so we can delete temp files
            #demLayer = input
            clippedDemLayers.append(self.clip_dem_layer(i, input))
            #self.create_contours(i, demLayer, destinationDirPath)
        
        # Error checking
        res = [i for i in clippedDemLayers if i == None]
        if len(res) > 0:
            return None
        
        # Merge Layer (if more than one)
        mergedDemFilePath = self.perform_merge(clippedDemLayers)
        print(mergedDemFilePath)
        if mergedDemFilePath == None:
            return None
        # Generate and reproject contour
        res = self.create_and_reproject_contour(mergedDemFilePath, destinationDirPath, obj, utmEPSG)
        return res

    def perform_merge(self, clippedDemLayers):#, inputContourFiles, unionContourFiles):
        if len(clippedDemLayers) == 0:
            return None
        elif len(clippedDemLayers) == 1:
            return clippedDemLayers[0]
        
        mergedDemFilePath = os.path.join(TEMP_DIR, 'merged_dem.tif')
        params = {
            'INPUT': clippedDemLayers,
            'DATA_TYPE' : 5, 
             'NODATA_INPUT' : None, 
             'NODATA_OUTPUT' : None, 
             'OPTIONS' : '', 
             'OUTPUT' : mergedDemFilePath, 
             'PCT' : False, 
             'SEPARATE' : False                    
            }
        try:
            processing.run("gdal:merge", params)
        except:
            mergedDemFilePath = None
        return mergedDemFilePath
    
    def create_and_reproject_contour(self, demFilePath, destinationDirPath, obj, utmEPSG):
        resolution = int(self.dlg.spinBoxContourResolution.value())
        contourTempFilePath = os.path.join(TEMP_DIR, 'contours_temp.shp')
        paramsContour = {
            'INPUT': demFilePath,
            'OUTPUT': contourTempFilePath,
            'BAND': 1,
            'CREATE_3D': True,
            'EXTRA': '',
            'FIELD_NAME': 'ELEV',
            'IGNORE_NODATA': False,
            'INTERVAL': resolution,
            'NODATA': None,
            'OFFSET': 0
        }
        processing.run("gdal:contour", paramsContour)
        contourFinalFilePath = os.path.join(destinationDirPath, '{}.shp'.format(obj))
        # reproject contour
        params = { 
            'INPUT' : contourTempFilePath, 
            'TARGET_CRS': utmEPSG,#"EPSG:{}".format(utmEPSG),
            'OUTPUT' : contourFinalFilePath
            }
        try:
            processing.run("native:reprojectlayer", params)
            return contourFinalFilePath
        except:
            return None
    
    def clip_dem_layer(self, i, input):
        studyAreaLayerID = self.return_layer_id_from_name(LAYER_STUDY_AREA)
        
        studyAreaLayer = [layer for layer in self.iface.mapCanvas().layers() if layer.id() == studyAreaLayerID][0]
        print("CURRENT_DIR: "+CURRENT_DIR)
        print("TEMP_DIR: "+TEMP_DIR)
        utmEPSG = studyAreaLayer.crs()
        clippedDemLayerPath = os.path.join(TEMP_DIR, 'clipped_dem{}.tif'.format(i))
        print("path: "+clippedDemLayerPath)
        params = {
            'INPUT': input,
            'MASK': studyAreaLayer,
            'OUTPUT': clippedDemLayerPath,
            'ALPHA_BAND': False,
            'CROP_TO_CUTLINE': True,
            'DATA_TYPE': 0,
            'EXTRA': '',
            'KEEP_RESOLUTION': True,
            'MULTITHREADING': False,
            'NODATA': None,
            'OPTIONS': '',
            'SET_RESOLUTION': False,
            'SOURCE_CRS': None,
            'TARGET_CRS': None,
            'X_RESOLUTION': None,
            'Y_RESOLUTION': None
        }
        try:
            processing.run("gdal:cliprasterbymasklayer", params)
            return clippedDemLayerPath
        except:
            return None

    def clean_temp_directory(self):
        QgsApplication.processEvents()

        for tempFile in os.listdir(TEMP_DIR):
            try:
                os.remove(os.path.join(TEMP_DIR, tempFile))
            except:
                pass



class download_thread(QThread):
    def __init__(self, url, temp_dir):
        QThread.__init__(self)
        self.url = url
        self.temp_directory = temp_dir
        self.msg = ""

    def run(self):
        try:
            r = requests.get(self.url, stream=True, verify=False)
            z = zipfile.ZipFile(io.BytesIO(r.content))
            z.extractall(self.temp_directory)
            self.msg = "Download complete!"
        except:
            self.msg = "Could not download DEM image file!"


#class progress_bar_thread(QThread):
#    def __init__(self, progressBar):
#        QThread.__init__(self)
#        self.progressBar = progressBar
#        self.count = 0
#
#    def run(self):
#        while True:
